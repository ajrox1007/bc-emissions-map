// Server-side audit PDF generation using jsPDF (no html2canvas)
import jsPDF from "jspdf";
import { getFieldsForCallType } from "./call-flows";

interface CallSessionData {
  id: string;
  twilioCallSid: string;
  callerNumber: string;
  callerName: string | null;
  callerEmail: string | null;
  callerAddress: string | null;
  callType: string | null;
  status: string;
  intakeData: string | null;
  startedAt: Date;
  endedAt: Date | null;
  duration: number | null;
  summary: string | null;
  turns: {
    role: string;
    content: string;
    turnNumber: number;
    timestamp: Date;
  }[];
}

function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}m ${secs}s`;
}

function formatDate(date: Date): string {
  return new Date(date).toLocaleString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    timeZoneName: "short",
  });
}

function formatFieldLabel(key: string): string {
  return key
    .replace(/([A-Z])/g, " $1")
    .replace(/^./, s => s.toUpperCase())
    .trim();
}

export function generateAuditPdf(session: CallSessionData): string {
  const doc = new jsPDF({ unit: "mm", format: "a4" });
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - margin * 2;
  let y = 0;
  let pageNum = 1;

  function checkPageBreak(needed: number) {
    if (y + needed > pageHeight - 25) {
      addFooter();
      doc.addPage();
      pageNum++;
      y = 20;
    }
  }

  function addFooter() {
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 10, { align: "center" });
    doc.text("Generated by Elevate Edge AI Phone Agent", margin, pageHeight - 10);
  }

  // === HEADER ===
  // Emerald gradient bar
  doc.setFillColor(5, 150, 105); // emerald-600
  doc.rect(0, 0, pageWidth, 28, "F");
  doc.setFillColor(13, 148, 136); // teal-600
  doc.rect(0, 24, pageWidth, 4, "F");

  // Title
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text("Call Intake Audit", margin, 14);

  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.text("Elevate Edge HVAC", margin, 21);

  // Date on right
  doc.setFontSize(9);
  doc.text(formatDate(session.startedAt), pageWidth - margin, 14, { align: "right" });

  y = 38;

  // === CALL OVERVIEW ===
  doc.setTextColor(5, 150, 105);
  doc.setFontSize(13);
  doc.setFont("helvetica", "bold");
  doc.text("Call Overview", margin, y);
  y += 2;

  // Divider
  doc.setDrawColor(5, 150, 105);
  doc.setLineWidth(0.5);
  doc.line(margin, y, margin + contentWidth, y);
  y += 6;

  doc.setTextColor(60, 60, 60);
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");

  const overviewRows = [
    ["Call Type", (session.callType || "Unknown").charAt(0).toUpperCase() + (session.callType || "unknown").slice(1)],
    ["Caller Number", session.callerNumber],
    ["Caller Name", session.callerName || "Not provided"],
    ["Caller Email", session.callerEmail || "Not provided"],
    ["Caller Address", session.callerAddress || "Not provided"],
    ["Date/Time", formatDate(session.startedAt)],
    ["Duration", session.duration ? formatDuration(session.duration) : "N/A"],
    ["Status", session.status.charAt(0).toUpperCase() + session.status.slice(1)],
    ["Twilio SID", session.twilioCallSid],
  ];

  for (const [label, value] of overviewRows) {
    checkPageBreak(7);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(100, 100, 100);
    doc.text(label + ":", margin, y);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(30, 30, 30);
    doc.text(value, margin + 40, y);
    y += 6;
  }

  y += 6;

  // === SUMMARY ===
  if (session.summary) {
    checkPageBreak(20);
    doc.setTextColor(5, 150, 105);
    doc.setFontSize(13);
    doc.setFont("helvetica", "bold");
    doc.text("Call Summary", margin, y);
    y += 2;
    doc.setDrawColor(5, 150, 105);
    doc.line(margin, y, margin + contentWidth, y);
    y += 6;

    doc.setTextColor(60, 60, 60);
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    const summaryLines = doc.splitTextToSize(session.summary, contentWidth);
    for (const line of summaryLines) {
      checkPageBreak(6);
      doc.text(line, margin, y);
      y += 5;
    }
    y += 6;
  }

  // === COLLECTED INTAKE DATA ===
  if (session.intakeData && session.callType) {
    let intakeObj: Record<string, string> = {};
    try {
      intakeObj = JSON.parse(session.intakeData);
    } catch {
      // skip
    }

    const filledEntries = Object.entries(intakeObj).filter(([, v]) => v);
    if (filledEntries.length > 0) {
      checkPageBreak(20);
      doc.setTextColor(5, 150, 105);
      doc.setFontSize(13);
      doc.setFont("helvetica", "bold");
      doc.text("Collected Intake Data", margin, y);
      y += 2;
      doc.setDrawColor(5, 150, 105);
      doc.line(margin, y, margin + contentWidth, y);
      y += 6;

      const fields = getFieldsForCallType(session.callType);

      // Table header
      checkPageBreak(8);
      doc.setFillColor(240, 253, 244); // emerald-50
      doc.rect(margin, y - 4, contentWidth, 8, "F");
      doc.setTextColor(5, 150, 105);
      doc.setFontSize(9);
      doc.setFont("helvetica", "bold");
      doc.text("Field", margin + 2, y);
      doc.text("Value", margin + 55, y);
      y += 6;

      doc.setTextColor(30, 30, 30);
      doc.setFont("helvetica", "normal");

      for (const [key, value] of filledEntries) {
        const field = fields.find(f => f.key === key);
        const label = field?.label || formatFieldLabel(key);
        const valueLines = doc.splitTextToSize(value, contentWidth - 57);
        const rowHeight = Math.max(valueLines.length * 5, 6);

        checkPageBreak(rowHeight + 2);

        // Alternating row color
        const rowIndex = filledEntries.indexOf([key, value]);
        if (rowIndex % 2 === 0) {
          doc.setFillColor(249, 250, 251);
          doc.rect(margin, y - 4, contentWidth, rowHeight + 2, "F");
        }

        doc.setFont("helvetica", "bold");
        doc.setTextColor(80, 80, 80);
        doc.text(label, margin + 2, y);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(30, 30, 30);
        for (let i = 0; i < valueLines.length; i++) {
          doc.text(valueLines[i], margin + 55, y + i * 5);
        }
        y += rowHeight + 2;
      }

      y += 6;
    }
  }

  // === FULL TRANSCRIPT ===
  if (session.turns.length > 0) {
    checkPageBreak(20);
    doc.setTextColor(5, 150, 105);
    doc.setFontSize(13);
    doc.setFont("helvetica", "bold");
    doc.text("Full Transcript", margin, y);
    y += 2;
    doc.setDrawColor(5, 150, 105);
    doc.line(margin, y, margin + contentWidth, y);
    y += 6;

    const sortedTurns = [...session.turns].sort((a, b) => a.turnNumber - b.turnNumber);

    for (const turn of sortedTurns) {
      const isAgent = turn.role === "agent";
      const label = isAgent ? "Agent" : "Caller";
      const timestamp = new Date(turn.timestamp).toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });

      const contentLines = doc.splitTextToSize(turn.content, contentWidth - 10);
      const blockHeight = contentLines.length * 5 + 10;

      checkPageBreak(blockHeight);

      // Role label + timestamp
      doc.setFontSize(9);
      doc.setFont("helvetica", "bold");
      if (isAgent) {
        doc.setTextColor(5, 150, 105); // emerald
      } else {
        doc.setTextColor(59, 130, 246); // blue
      }
      doc.text(label, margin, y);

      doc.setFont("helvetica", "normal");
      doc.setTextColor(150, 150, 150);
      doc.text(timestamp, margin + 18, y);
      y += 5;

      // Content
      doc.setTextColor(50, 50, 50);
      doc.setFontSize(9);
      for (const line of contentLines) {
        checkPageBreak(6);
        doc.text(line, margin + 4, y);
        y += 5;
      }
      y += 3;
    }
  }

  // Final footer
  addFooter();

  // Return base64
  const pdfOutput = doc.output("datauristring");
  // Extract just the base64 part after the data URI prefix
  const base64 = pdfOutput.split(",")[1];
  return base64;
}
